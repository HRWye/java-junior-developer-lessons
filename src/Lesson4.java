import java.util.Arrays;
import java.util.Scanner;

public class Lesson4 {
    public static void main(String[] args) {
        //область видимости переменных ограничивается фигурными скобками

        //примитивные типы данных
        int a = 10;//отдельный участок памяти
        int b =a;//отдельный участок памяти
        a=100;

        //ссылочные типы данных
        Scanner sc =new Scanner(System.in);
        Scanner in = sc;//для этих строчек создается одна область памяти

        //массив - это объект, представляющий некоторую непрерывную область данных одного типа
        //элемент массива имеет свой индекс, нумерация начинается с 0
        //длина массива = количество элементов массива

        //создаем массив
        int[] ints1= new int[7];//число в квадратных скобках-это размер массива//способ более предпочтительный
        //int ints1[]=... так тоже можно
        //этот массив уже наполнен данными [0,0,0,0,0,0,0,0]
        //boolean заполняется false
        //char - 'u\0000
        System.out.println(ints1);//выводится говно какое-то, поэтому так массив не выводим
        System.out.println(Arrays.toString(ints1)); //импортируем класс Arrays//метод toString переводит значения в строчку

        int[] ints2 = {6, -90, 56, 12, 0, -44};//использую синтаксис фигурных скобок, можем создать массив уже со значениями
        System.out.println(Arrays.toString(ints2));

        ints2 = new int[45];//выделилась новая область памяти, к прошлому массиву мы потеряли доступ, но он все еще находится в памяти
        System.out.println(Arrays.toString(ints2));

        //ints2 = {34, 78, 12}; такой синтаксис использовать нельзя
        ints2 = new int[]{34, 78, 12};//так делать можно, тоже создается новая область памяти

        //длина массива - положительное число типа int
        int len = 10;
        int[] ints3 = new int[len];//длину массива можно прописывать через переменную
        int[] ints4 = new int[len+5];//можно задавать и через выражения, но главное чтобы получался тип int
        //массив теоретически может быть и с нулевой длиной
        System.out.println(ints4.length);//через '.length' можно узнать размер массива

        //доступ к элементам массива
        System.out.println(ints4[3]);//выводим элемент массива с индексом 3
        int arrElem = ints4[3];
        ints4[2] = 56;//присвоили элементу массива с индексом 2 значение 56 (третий элемент массива)
        System.out.println(Arrays.toString(ints4));
        //индексация начинается с нуля потому что индекс указывает на сдвиг памяти, и первый элемент по сути характеризует что сдвиг у него нулевой

        //многомерный массив
        //[[0,0,0,0],[0,0,0,0],[0,0,0,0]] - двумерный массив
        int[][] ints5 = new int[3][4];//первые скобки это размер внешнего массива, вторые - длина вложенных массивов
        System.out.println(Arrays.deepToString(ints5));//вывод многомерного массива в консоль
        //[[0,0],[0,0,0],[0,0,0,0]]-выведем более разнообразный массив
        int[][] ints6= new int[3][];//[null,null,null]- null это отсутствие ссылки
        ints6[0]= new int[2];//[[0,0],null,null]
        ints6[1]= new int[3];//[[0,0],[0,0,0],null]
        ints6[2]= new int[4];//[[0,0],[0,0,0],[0,0,0,0]]
        ints6[2][1] = 90;
        System.out.println(Arrays.deepToString(ints6));

        //перебор массива for
        // 0  1 2  3 4 - индексы
        //{3,-6,12,0,4} - элементы
        int[] ints7={3,-6,12,0,4};
        int sum = 0;
        for (int i = 0;i<ints7.length ;i++){//i - индекс элемента массива
            ints7[i]*=ints7[i];
            sum +=ints7[i];}
        System.out.println(Arrays.toString(ints7)+" Сумма элементов: "+sum);
        //найти суммы элементов массива

        //перебор массива for each
        //здесь мы не можем изменять значения элементов массива и он не предоставляет доступа к индексам
        for (int elements:ints7){//на каждой итерации переменной element присваивается значение элемента массива
            System.out.println(elements);
            sum+=elements;
        }

        //найти и вывести в консоль минимальное значение элемента массива
        double[] ints8 = {3.7, -6.2, 12.9, 0.4, 4.1};
        double min=ints8[0];
        for (double i:ints8){
            if (i<min) i=min;}
        System.out.println("Минимальное значение: "+min);

        //вывести в консоль случайный элемент массива
        System.out.println("Случайный элемент массива: "+ints8[(int) (Math.random()*ints8.length)]);

        //сортировка
        Arrays.sort(ints8);//в порядке возрастания
        System.out.println(Arrays.toString(ints8));

        //метод бинарного поиска
        int element= Arrays.binarySearch(ints8, 3.7);//то есть в массиве мы ищем элемент со значением 3.7
        System.out.println(element);//выводит индекс этого элемента

        element= Arrays.binarySearch(ints8, 4);
        System.out.println(element);

        element= Arrays.binarySearch(ints8, 13);
        System.out.println(element);
        //Если значение меньше нуля, то выводится отрицательное значение.
        //Предполагается, что поиск применяется к отсортированным массивам, только в это случае он может сказать на каком бы месте мог стоять массив (-(i+1))

        //копирование массивов
        double[] ints9 = {3.7, -6.2, 12.9, 0.4, 4.1};
        //double[] ints10=ints9; - так копировать массивы нельзя, обращение будет к одной области памяти
        double[] cloneInts9=ints9.clone();//вызываем метод '.clone' у массива который хотим скопировать
        //это уже будут два разных массива занимающие разные области памяти
        double[] copyInts9=Arrays.copyOf(ints9, 3);//благодаря этому методу мы можем указать сколько элементов хотим скопировать
        System.out.println(Arrays.toString(copyInts9));
        double[] newDouble= new double[10];
        System.arraycopy(ints9, 1, newDouble, 3,2);
        //(массив, который копируем; с какого элемента, куда копируем; с какого индекса в новом массиве начнется копирование; длина нового массива)
        System.out.println(Arrays.toString(newDouble));

        //на след занятие: алгоритм быстрой сортировки
    }
}
